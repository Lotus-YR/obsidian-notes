#### 1 处理机调度的层次和调度算法的目标
what when how
##### 处理机调度的层次
- 高级调度（长程调度、作业调度）
	根据某种算法决定将**外存**上处于**后备队列**中的哪几个作业作业调入内存，为其创建进程、分配必要资源，放入**就绪队列**
	运行周期较长

- 低级调度（短程调度、进程调度、微观调度）
	根据某种算法决定**就绪队列**中的哪个进程获得**处理机**，并分派程序将处理机分配给被选中的进程
	运行频率最高

- 中级调度（中程调度、内存调度）
	提高==内存利用率和系统吞吐量==
	*就绪驻外存状态/挂起状态*：使那些暂时不能运行的进程不再占用宝贵的内存资源，而将它们调至外存上去等待
	当这些进程重又具备运行条件且内存又稍有空闲时，由**中级调度**来决定把**外存上**的那些又具备运行条件的**就绪进程重新调入内存**，并修改其状态为就绪状态，挂在就绪队列上等待进程调度
	中级调度实际上就是存储器管理中的对换功能

##### 处理机调度算法的目标
1. 共同目标
	- 资源利用率
	- 公平性
	- 平衡性
	- 策略强制执行![[Pasted image 20240621164751.png|400]]
2. 批处理系统的目标
	- 平均周转时间短
	- 系统吞吐量高
	- 处理机利用率高
3. 分时系统的目标
	- 响应时间快
	- 均衡性
4. 实时系统的目标
	- 截至时间的保证
	- 可预测性

#### 2 作业与作业调度⭐
##### 批处理系统中的作业
###### 作业和作业步
根据需要处理工作的类型，分为**计算型和I/O型**作业
按照作业提交方式，分为**批处理作业和终端型作业**

一个系统能够接纳作业的个数称为系统的多道程序度

作业步：
•每个作业经过若干个相互独立、相互关联的顺序加工步骤得到结果，每个加工步骤就是作业步
•典型作业步：编译、链接装配、运行


**作业、进程、程序**
作业：用户提交给系统的一个任务，在用户向计算机提交作业后，系统将它放入外存中的作业等待队列中等待执行。
进程：完成用户任务的执行实体，是向系统申请分配资源的基本单位。任一进程，只要它被创建，总有相应的部分存在于内存中。

作业与进程最主要的区别是：前者是由用户提交，后者是由系统自动生成；前者以用户任务为单位，后者是操作系统控制的单位。

程序是进程的一部分，是进程的实体


###### 作业控制块（Job Control Block, JCB）
JCB是作业在系统中存在的标志，保存了系统对作业进行**管理和调度**所需的全部信息
作业进入系统，系统为它建立一个JCB，根据作业类型插入相应的**后备队列**中，作业调度程序依据调度算法将作业装入**内存**

JCB通常包含：作业标识、作业类型、作业状态、调度信息（优先级、作业已运行时间）、资源需求等

作业运行的三个阶段和三种状态
	阶段：收容、运行和完成
	状态：
		后备状态：经过SPOOLing系统输入到磁盘输入井，等待调入内存
		运行状态：被作业调度程序选中，建立相应的进程后，调入内存
		完成状态：进程运行结束或发生错误而终止时，作业进入完成状态，终止作业程序将负责善后处理

##### 作业调度的主要任务
###### 作业调度 = 接纳调度
作业调度的主要功能是根据**作业控制块**中的信息，审查系统能否满足用户作业的资源需求，以及按照一定的算法，从外存的后备队列中选取某些作业调入内存，并为它们创建进程、分配必要的资源。再将新创建进程插入就绪队列，准备执行。

对用户而言，希望自己作业的周转时间尽可能的少
对系统来说，希望作业的平均周转时间尽可能少，有利于提高 CPU 的利用率和系统的吞吐量。

每个系统在选择作业调度算法时，既应考虑用户的要求，又能确保系统具有较高的效率。

![[Pasted image 20240622111043.png|400]]
###### 接纳多少作业
作业调度每次要接纳多少个作业进入内存，取决于**多道程序度**(Degree of Multiprogramming)， 即允许多少个作业同时在内存中运行

当内存中同时运行的作业数目太多时，可能会影响到系统的服务质量

在内存中同时运行作业的数量太少时，会导致系统的资源利用率和系统吞吐量太低

多道程序度的确定应根据系统的规模和运行速度等情况做适当的折衷

###### 接纳哪些作业
应将哪些作业从外存调入内存，取决于所采用的调度算法
•先来先服务调度算法（最简单）
First-Come First-Served, FCFS
•短作业优先调度算法（较常用）
Shortest Job/Process First, SJF/SPF
•基于作业优先级调度算法（较常用）
Priority Scheduling Algorithm, PSA
•响应比高者优先调度算法（比较好）
Highest Response Ratio Next/Frist, HRRN/HRRF

##### 先来先服务(FCFS)和短作业优先(SJF)调度算法
###### 先来先服务
既可用于作业调度，也可用于进程调度。

作业调度：每次调度都是从**后备作业队列**中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。

进程调度： 每次调度是从**就绪队列**中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。

有利于长作业(进程)，而不利于短作业(进程)
有利于 CPU 繁忙型的作业，而不利于 I/O 繁忙型的作业。CPU 繁忙型作业是指该类作业需要大量的 CPU 时间进行计算，而很少请求 I/O。通常的科学计算便属于 CPU 繁忙型作业。I/O 繁忙型作业是指 CPU进行处理时需频繁地请求 I/O。目前的大多数事务处理都属于 I/O 繁忙型作业。

###### 短作业/进程优先
对短作业或短进程优先调度的算法

短作业优先(SJF)调度算法：从**后备队列**中选择一个或若干个**估计运行时间最短**的作业，将它们调入内存运行

短进程优先(SPF)调度算法：从**就绪队列**中选出一个**估计运行时间最短**的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度

缺点：
- 必须预知作业的运行时间：很难估计，一般会偏长估计
- 该对长作业不利，长作业的周转时间会明显增长，甚至出现饥饿现象
- 完全未考虑作业紧迫程度，不能保证紧迫性作业(进程)会被及时处理
- 人机无法实现交互
- 由于作业(进程)的长短只是根据用户所提供的估计执行时间而定的，而用户又可能会有意或无意地缩短其作业的估计运行时间，致使该算法不一定能真正做到短作业优先调度。

##### 优先级调度算法(PSA)和高响应比优先调度算法(HRRN)
###### 优先级调度算法
FCFS调度算法：作业等待时间是作业的优先级
SJF/SPF调度算法：作业/进程的长短是作业/进程的优先级
PSA：基于作业的紧迫程度，由外部赋予作业响应的优先级

###### 高相应比优先调度算法
- 高响应比优先 (Highest Response Ratio Next, HRRN)
	为每个作业引入动态优先权，使作业的优先级随着等待时间的增加而以速率a提高，则长作业在等待一定的时间后，必然有机会分配到处理机。该优先权的变化规律可描述为：![[Pasted image 20240622112659.png|290]]
	等待时间与服务时间之和就是系统对该作业的响应时间，故该优先权又相当于响应比 RP。据此，又可表示为：![[Pasted image 20240622112726.png|300]]
	如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈高，因而该算法**有利于短作业**。当要求服务的时间相同时，作业的优先权决定于其等待时间，等待时间愈长，其优先权愈高（先来先服务）
	对于长作业，作业的优先级可以随等待时间的增加而提高，当其等待时间足够长时， 其优先级便可升到很高，从而也可获得处理机。
	既照顾了短作业，又考虑了作业到达的先后次序，不会使长作业长期得不到服务，该算法实现了一种较好的折衷。
	在利用该算法时，每进行调度之前，都须先做**响应比的计算**，这会增加系统开销
#### 3 进程调度
##### 进程调度的任务、机制和方式
进程调度=低级调度=短程调度（操作最频繁的调度）

###### 进程调度的任务
保存处理机的现场信息
按某种算法选取进程
把处理器分配给进程

###### 进程调度的机制
排队器
分派器
上下文切换器

###### 进程调度的方式
非抢占方式
抢占方式
	优先权原则
	短进程优先原则
	时间片原则

###### 进程调度的主要算法
轮转调度算法 Time Round-Robin, TRR/RR
优先级调度算法 Priority Scheduling Algorithm, PSA
多队列调度算法 Multi-level Queue
多级反馈队列调度算法 Multi-level Feed Queue
基于公平原则的调度算法

##### 轮转调度算法 TRR/RR
###### 基本原理
分时思想；
首先将处理器的处理时间划分为**大小相等的时间片**;
就绪队列按照**FCFS**形成;
调度程序每次从就绪队列中选择队首的进程，为之分配处理器的一个时间片并让进程运行;
当进程运行的时间片到时，强迫进程放弃处理器，到就绪队列中**再次排队**，并将处理器的下一个时间片分配给就绪队列中队首的进程;
所有就绪队列的进程按照这样的形式轮转使用处理器时间片

###### 进程切换时机
•若一个时间片**尚未用完**，正在运行的进程便已经完成，就立即激活调度程序，将它从就绪队列中删除，再调度就绪队列中队首的进程运行，并启动一个新的时间片。
•在一个**时间片用完**时，计时器中断处理程序被激活。如果进程尚未运行完毕，调度程序将把它送往就绪队列的末尾。

###### 时间片大小的确定
•时间片的大小对系统性能有很大的影响，
•时间片过小：频繁发生中断、进程切换，增加系统的开销；
•时间片过大：使得每个进程都能在一个时间片内完成，时间片轮转算法便退化为 FCFS 算法，无法满足交互式用户的需求。

##### 优先级调度算法 PSA
###### 优先级调度算法的类型
处理器分配给就绪队列中优先级最高的进程
非抢占式优先级调度算法：执行完成或放弃
抢占式优先级调度算法：优先级高者剥夺低者

###### 优先级类型
静态优先级
动态优先级

##### 多队列调度算法
> 大家都是高贵的系统进程
![[Pasted image 20240622195011.png|300]]


##### 多级反馈队列调度算法
###### 调度机制
不必事先知道各种进程所需的执行时间，可以满足各种类型进程的需要，目前被公认的一种较好的进程调度算法。
设置**多个就绪队列**，并为各个队列赋予不同的优先级，第一个队列的优先级最高，优先权愈高的队列中，时间片愈小
每个队列都**采用FCFS算法**
	•当新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则等待调度。
	•当轮到该进程执行时，如它能在该时间片内完成，便可撤离系统。否则，即它在一个时间片结束时尚未完成，调度程序将其转入第二队列的末尾等待调度，依此类推。
	•当进程最后被降到第n队列后，在第n队列中便采取按RR方式运行。

###### 调度算法的性能
如果规定第一个队列的时间片略大于多数人机交互所需之处理时间时，便能较好地满足各种类型用户的需要。
	•终端型用户：可获得较好的交互性;
	•短批处理作业用户：通常在前几个队列中可执行完毕;
	•长批处理作业用户：依次在前面多个队列总运行，然后按照轮转方式运行，不必担心长期得不到处理。



##### 基于公平原则的调度算法
###### 保证调度算法
向用户所做出的保证并不是优先运行，而是明确的性能保证，该算法可以做到调度的公平性。
系统应具备以下功能:
	•跟踪计算每个进程自创建以来已经执行的处理时间;
	•计算每个进程应获得的处理机时间，即自创建以来的时间除以n;
	•计算进程获得处理机时间的比率，即进程实际执行的处理时间和应获得的处理机时间之比;
	•比较各进程获得处理机时间的比率，如进程A的比率最低，为0.5,而进程B的比率为0.8，进程C的比率为1.2等;调度程序应选择比率最小的进程将处理机分配给它，并让该进程一直运行， 直到超过最接近它的进程比率为止。


###### 公平分享调度算法
调度的公平性主要针对用户而言，使所有用户能获得相同的处理机时间，或所要求的时间比例;
调度以进程为单位，需考虑每个用户所拥有的进程数目
	•用户1启动A/B/C/D共计4个进程
	•用户2启动E共计1个进程
	•保证用户具有相同的处理机时间，则调度系列:
		  A E B E C E D E A E B E C E D E ...
	•保证用户1获得的处理机时间是用户2的两倍，调度系列:
		  A B E C D E A B E C D E ...
 
#### 4 实时调度
##### 基本条件
###### 提供必要的信息
就绪时间
开始截至时间和完成截至时间
处理时间
资源要求
优先级
###### 系统处理能力强
假定系统中有m个周期性的硬实时任务，它们的处理时间可表示为 Ci，周期时间表示为 Pi，则在单处理机情况下，可调度的限制条件为：
![[Pasted image 20240622200508.png|200]]
提高系统的处理能力
	•增强其处理能力，显著减少对每一个任务的处理时间
	•采用多处理机系统

###### 采用抢占式调度机制
含有硬实时任务的实时系统中，广泛采用抢占机制。
小型实时系统，如果能预知任务开始截止时间，则采用非抢占调度机制，以简化调度程序和对任务调度花费的系统开销

###### 具有快速切换机制
对外部中断的快速响应能力，为使在紧迫的外部事件请求中断时系统能及时响应
快速的任务分派能力。在完成任务调度后，便应进行任务切换。为了提高分派程序进行任务切换时的速度，应使系统中的每个运行功能单位适当地小，以减少任务切换的时间开销

##### 实时调度算法的分类
###### 非抢占式调度算法
非抢占式轮转调度算法
非抢占式优先调度算法


###### 抢占式调度算法
基于时钟中断的抢占式优先权调度算法
立即抢占的优先权调度算法


##### 最早截至时间优先算法 EDF
根据任务的开始截止时间来确定任务的优先级
截止时间愈早，其优先级愈高
可用于抢占式调度，也可用于非抢占式调度方式
	•非抢占式调度方式用于非周期实时任务
	•抢占式调度方式用于周期实时任务


##### 最低松驰度优先算法 LLF
根据任务紧急(或松弛)的程度，来确定任务的优先级。
任务的**紧急程度愈高，优先级就愈高**，以使之优先执行
主要用于**可抢占**的调度方式中
系统中有一个按松弛度排序的实时任务就绪队列，松弛度最低的排在最前面，调度程序总是选择队首任务执行。
==松弛程度 = 必须完成时间 - 其本身的运行时间 - 当前时间==
一个任务在400ms时必须完成，它本身需要运行150ms，则其松弛程度为400-150=250ms

##### 优先级倒置


#### 5 死锁概述
##### 资源问题
###### 可重用性资源和消耗性资源
可重用性资源
	可供用户重复多次使用
	设备、文件
可消耗性资源
	临时性资源

###### 可抢占性资源和不可抢占性资源
可抢占性资源
	CPU
不可抢占性资源
	打字机

##### 计算机系统中的死锁
死锁原因：
- 竞争不可抢占性资源
- 竞争可消耗性资源
- 进程推进顺序不当

##### 死锁的定义、必要条件和处理方法
死锁：无限等待

必要条件：
- 互斥条件
- 请求和保持条件（保持 且又提出新请求
- 不可抢占条件
- 循环等待条件

处理死锁的方法：
- 预防死锁
- 避免死锁
- 检测死锁
- 解除死锁


#### 6预防死锁⭐
破坏必要条件
##### 破坏“请求和保持”条件
第一种协议
一次性申请全部资源

第二种协议
提供运行初期所需资源
用完后释放再请求

##### 破坏“不可抢占”条件


##### 破坏“循环等待”条件
线性排序


#### 7 避免死锁
##### 系统安全状态
安全状态：指系统按某种顺序<P1，P2，…，Pn>，来为每个进程分配其所需资源，直至最大需求，使每个进程都可顺序完成。
**安全序列**：一个进程序列<P1，P2，…，Pn>是安全的，如果对于每一个进程Pi(1≤i≤n），它以后尚需要的资源量不超过系统当前剩余资源量与所有进程Pj (j<i )当前占有资源量之和，系统处于安全状态
如果系统不存在安全序列，则称系统处于不安全状态
并非所有不安全状态都是死锁状态，但当系统进入不安全状态后，便可能进入死锁状态.
只要系统处于安全状态，便可避免死锁状态
避免死锁的实质是使系统**不进入不安全状态**


##### 利用银行家算法避免死锁
银行家算法中的数据结构
Available：可利用资源向量
Max：最大需求矩阵
Allocation：分配矩阵
Need：需求矩阵



#### 8 死锁的检测与解除
##### 死锁的检测
？？

死锁的充分条件


##### 死锁的解除
 