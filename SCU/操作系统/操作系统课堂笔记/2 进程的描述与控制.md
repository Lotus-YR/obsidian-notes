#### 1 前趋图和程序执行
##### 前趋图
前趋图：描述程序执行先后顺序（有向无循环

##### 程序执行


#### 2 进程的描述
##### 进程的定义和特征
**进程**是资源分配和处理器调度的*基本单位*，是操作系统中最活跃的因素，也是操作系统*并发性、共享性、虚拟性、异步性*的体现

为避免进程切换导致的系统开销过大，现代OS在进程的基础上引入了*线程*的概念，用==线程代替进程成为处理器调度的基本单位==

###### 进程实体
- 程序段
- 相关的数据段
- 进程控制块（Process Control Block, PCB）

进程与程序
程序是静态的，是以文件形式存放在磁盘上的代码序列。进程是动态的，是不断向前推进的过程，进程具有各种状态并可以在状态之间转换

###### 特征
- 结构性：进程包含有描述进程信息的*数据结构*（包含进程控制块、程序块和代码块等）和运行在进程上的程序，OS用PCB描述和记录进程的动态变化过程。
- 动态性：*最基本特征*，是程序执行过程，有一定的生命期：由创建而产生、由调度而执行，因得不到资源而暂停，由撤消而死亡。而程序是静态的，它是存放在介质上一组有序指令的集合，无运动的含义。
- 并发性：进程的*重要特征*，也是OS的重要特征。指多个进程实体同存于内存中，能在一段时间内同时运行。而程序（没有建立PCB）是不能并发执行。
- 独立性：进程是一个能独立运行的*基本单位*，即是一个独立获得资源和独立调度的单位，而未简历PCB的程序不能作为独立单位参加运行、获取资源。
- 异步性：进程按各自独立的不可预知的速度向前推进（即按异步方式进行），正是这一特征导致程序执行的不可再现性，因此OS必须采用某种措施来限制各进程推进序列以保证各程序间正常协调运行。

##### 进程的状态
###### 三种基本状态
就绪状态
执行状态
阻塞状态
![[Pasted image 20240307143409.png|200]]

###### 两种常见状态
创建状态
终止状态

###### 挂起操作
系统资源的需要
调节竞争或消除故障的需要
终端用户的需要
父进程的需要
调节进程的需要

引入挂起操作后三种基本状态的转换：
![[Pasted image 20240307145142.png|200]]

###### OS通过各种数据结构实现对信息的组织和维护
- OS将**资源抽象为数据结构**，并提供相关操作命令，用户借此执行相关操作，无需了解实现细节
- OS作为计算机资源的管理者，必须记录和查询各种资源的使用及各类进程运行情况的信息，对于这些**信息的组织和维护**也是通过简历和维护各种数据结构的方式实现
- 每个资源（资源信息表）和每个进程（进程信息表，又称为进程控制块PCB）都设置了一个数据结构，包含资源或进程的标识、描述、状态等信息和一批指针

##### 进程管理中的数据结构
###### 进程控制块 PCB
对进程本质属性的描述，是操作系统管理进程所需要的基本信息

作用
- 作为独立运行基本单位的标志
- 能实现间断性运行方式
- 提供**进程管理**所需要的信息
- 提供**进程调度**所需要的信息
- 实现与其他进程的同步与通信

进程控制块的组织方式
- 线性方式
- 链接方式 
	优点：直观
	缺点：进程状态变化
- 索引方式
	优点：快速得到进程控制块地址
	缺点：内存空间，搜索索引表需要时间

#### 3 进程控制
##### 操作系统内核
与硬件紧密结合的模块、常用设备驱动、运行频率的模块，安排在紧靠硬件的软件层次中，这些模块*常驻内存*，被称为*OS内核*
对软件进行保护，提高OS运行效率


处理机的执行状态
- 系统态（内核态/管态）：具有较高特权；OS通常运行在管态
- 用户态（目态）

##### 内核两大功能
支撑功能
- 中断处理：最基本的功能
- 时钟管理
- *原语操作*：若干条指令组成，执行过程中不允许被中断
资源管理功能
- 进程管理
- 存储器管理
- 设备管理

##### 进程创建
###### 创建步骤（create原语）
1. 命名进程：设置进程标志符
2. 申请空白PCB
3. 确定进程的优先级
4. 分配内存空间
5. 分配资源
6. 初始化PCB
7. 将进程插入到就绪队列
8. 通知OS其他管理模块（奔走相告）

###### 引起创建进程的事件
- 操作系统初始化
- 提供用户服务
- 分时系统用户登录
- 用户请求系统创建新进程
- 批处理作业的初始化和调度

###### 进程的层次结构
允许一个进程创建另一个进程，创建进程的进程为父进程Parent Process，被创建的进程为子进程Progeny Process，子进程可继续创建孙进程，形成树形结构的进程家族（组）

###### 引起进程终止的事件（原因）
正常结束：halt指令或log off
异常结束
	操作异常退出：保护错（写只读文件）、算术运算错、非法指令、特权指令错、I/O故障
	时间指标超限引起进程异常结束：运行超时、等待超时
	多个进程之间竞争资源
	内存的使用出错：越界错
外界干预
	父进程结束
	父进程请求
	操作系统终止：系统死锁

###### 进程的终止过程
第一步：根据被终止进程的标识符，从PCB集合中查找对应进程控制块并读出该进程的状态；
第二步：若被终止进程正处于执行状态，则终止该进程的执行，并设置调度标志为真，用于指示该进程被终止后应重新进行调度，选择一新进程，把处理机分配给它。
第三步：若进程还有子孙进程，应将其所有子孙进程终止，以防它们成为不可控制的。
第四步：将进程所占有的全部资源释放（还给父进程或系统），释放进程控制块（若该进成为执行态，要进行进程调度）。

第五步：将被终止进程（它的PCB）从所在队列（或链表）中移出，等待其他程序来收集相关信息。

#### 4 进程同步⭐
##### 进程同步的基本概念
###### 两种形式的制约关系
- 间接相互制约
- 直接相互制约

###### 进程同步和互斥
进程间的相互关系主要有三种：==同步、互斥、通信==

###### 临界资源
进程间应采取互斥方式

**生产者-消费者问题**
缓冲池：数组表示，具有n个(0，1，…，n-1)缓冲区
输入指针in：指示下一个可投放产品的缓冲区
输出指针out：指示下一个可从中获取产品的缓冲区
缓冲池采用循环组织，故：
	•输入加1表示成 in:= (in+1) % n；
	•输出加1表示成out:= (out+1) % n；
	•(in+1) % n=out时表示缓冲池满；
	•in=out则表示缓冲池空。
整型变量counter：
- 生产者投放产品counter加1；
- 消费者取走产品counter减1。
![[Pasted image 20240620092252.png|300]]


###### 临界区
每个进程中访问临界资源的那段代码称为临界区，即存取操作区域

进入区
临界区
退出区
剩余区

###### 临界区进入准则
- 单个入区：一次仅允许一个进程进入。
- 独自占用：处于临界区内的进程不可多于一个。如果已有一个进入临界区，其它试图进入的进程必须等待。
- 尽快退出：访问完后尽快退出，以让出资源。
- 落败让权：如果进程不能进入临界区，则应让出CPU，以免出现“忙等”现象。

###### 同步机制应遵循的**规则**
- 空闲让进
- 忙则等待：不允许两个以上的进程同时进入互斥区
- 有限等待
- 让权等待：处于等待状态的进程应放弃占用CPU，以使其他进程有机会得到CPU的使用权

##### 硬件同步机制
特殊的硬件指令解决临界区问题，在对临界区进行管理时，可以将标志看做一个锁，“锁开”进入，“锁关”等待，初始时锁是打开的。每个要进入临界区的进程必须先对锁进行测试，锁未开时等待，锁打开时立即把其锁上，以*阻止其它进程进入临界区*。为防止多个进程同时测试到锁为打开的情况，测试和关锁操作必须是连续的，不允许分开进行。
###### 关中断：关闭中断
方法：实现互斥的最简单的方法之一。每个进程在进入临界区之后关闭所有中断,在离开临界区之前才重新打开中断。
原理：由于禁止中断，时钟中断也被禁止，这样就不会把CPU切换到另外的进程。不必担心其它进程对它的干扰。
缺点：
	•滥用关中断权力可能导致严重后果；
	•关中断时间过长，会影响系统效率，限制了处理器交叉执行程序的能力；
	•关中断方法也不适用于多CPU系统，因为在一个CPU上关中断并不能防止进程在其它CPU上执行相同的临界段代码。

###### 利用Test-and-Set指令实现互斥：硬件指令TS，执行过程不可分割（即为原语）
进程在进入临界区之前，首先用TS指令测试lock，如果为FALSE则表示可进入，并将TRUE值赋值给lock；

###### 利用Swap指令实现进程互斥
可简单有效地实现互斥，为每一个临界资源设置一个全局布尔变量lock，初值为false

TS指令和Swap指令的缺点：
利用上述硬件指令虽能有效地实现进程互斥，但当临界资源忙碌时，其它访问进程必须不断地进行测试，处于一种“忙等”状态，**不符合“让权等待”的原则**，造成处理机浪费，同时也很难将它们用于解决复杂的进程同步问题


###### 进程同步机制
硬件同步机制：
	1. 关中断
	2. test and  set
	3. swap
软件方式：
	1. 锁机制（基本思想）
	2. 信号量机制（PV操作）（重中之重）

##### 信号量机制
原语操作（原子操作）
原语操作也称做“原子操作”(atomic action)，即一个操作中的所有动作要么全做要么全不做
PV操作、上锁等都是原子操作

###### 整型信号量
整型信号量最初由Dijkstra把整型信号量定义为一个用于表示**资源数目的整型量S**，它与一般整型量不同，除初始化外，仅能通过两个标准的原子操作(Atomic Operation) wait(S)和 signal(S)来访问，这两个操作被分别称为P、V操作
P操作：表示同步进程发出的检测信号量操作，检测**是否能够使用**临界资源
V操作：表示访问完临界资源的进程通知等待进程已经完成了临界资源的访问，将**临界资源释放**
不符合让权等待

```
wait(S){
	while(S<=0);
	S--;
}
signal(S){
	S++:
}
```

###### 记录型信号量（结构型信号量）
增加了一个进程链表指针list，用于链接所有等待的进程

记录型信号量在整型信号量的基础上进行了改进，让不能进入临界区的进程“让权等待”，即进程状态由运行转换为阻塞状态，进程进入阻塞队列中等待。

```
wait(semaphore *S){
	S.value = S.value - 1         //S.value的初值表示系统中某类资源的数目，因而又称为资源信号量
	if S.value < 0 then block(S,L)
}
signal(S){
	S.value = S.value + 1
	if S.value <= 0 then wakeup(S,L）//+1后仍小于0 说明有进程被阻塞 应唤醒第一个等待进程
}
```

###### AND型信号量
将进程运行过程中需要的所有资源一次性分配，待进程使用完后再一起释放

```
Swait(S1, S2, …, Sn){   
      While(TRUE){       
              if (S1 >=1 and … and Sn>=1 ){           
                    for( i=1;i<=n; i++)    Si--;
                    break;
              }else{
                    Place the process in the waiting queue associated  with the first Si found with Si < 1,and 
                    set the progress count of this process to the beginning of Swait operation
              }}}
Ssignal(S1, S2, …, Sn){   
             while(TRUE){          
                     for (i=1; i<=n; i++)
                    {               
                              Si++ ;               
                             Remove all the process waiting in the queue associated
                             with Si into the ready queue}}}
```

###### 信号量集
当进程需要申请的临界资源种类较多，每类临界资源个数较多时，如果用记录型信号量，进程每次只能一次申请或释放一个临界资源，非常麻烦。因此，引入信号量集

在每次分配之前，测试**资源数量是否大于可分配的下限值**
Swait(S1, t1, d1; ...; Sn, tn, dn);   （t：分配下限；d：需求值）
Ssignal(S1, d1; ...; Sn, dn);

一般“信号量集”可以用于各种情况的资源分配和释放。下面是几种特殊的情况：
1) Swait(S, d, d)表示每次申请d个资源，当资源数量少于d个时，便不予分配。
2) Swait(S, 1, 1)表示互斥信号量。
3) Swait(S, 1, 0)可作为一个可控开关(当S≥1时，允许多个进程进入临界区；当S=0时禁止任何进程进入临界区)。

由于一般信号量在使用时的灵活性，因此通常并不成对使用Swait和Ssignal。为了避免死锁可一起申请所有需要的资源，但**不一起释放**

##### 信号量的应用
信号量按联系进程的关系分成两类：
- 公用信号量（互斥信号量）
- 私用信号量（同步信号量）


###### 利用信号量实现进程互斥
进程A和进程B共用缓冲区，进程A和进程B并发执行，缓冲区是竞争访问的临界资源。用整型信号量实现进程同步。

为缓冲区设置整型信号量/互斥信号量mutex
设mutex的初值为1，取值范围（-1，0，1）
将各进程对临界区访问置于P(mutex)和V(mutex)之间

**对于并发进程A和进程B**：如果两个进程都能够访问缓冲区，哪个进程先访问缓冲区，==关键在于哪个进程先执行P(mutex)==。先执行的进程先进入缓冲区访问；后执行P(mutex)的进程等待，直到先进入缓冲区访问的进程用V(mutex)释放缓冲区为止。

**P操作和V操作必须成对出现**，缺少P操作将导致系统混乱，不能保证临界资源的互斥访问；缺少V操作将会使临界资源永远不被释放，使等待该资源而阻塞的进程不能被唤醒。

###### 利用信息量实现进程同步
信号量的设置是关键：将信号量is的初值设置为1，ps的初值设置为0。总是输入进程先进入缓冲区放入数据，计算进程先等待。输入进程将一条数据放入缓冲区后释放ps，计算进程才能进入缓冲区取走一条数据。

对于输入进程：如果计算进程没有进入缓冲区取走一条数据，输入进程不能再进入缓冲区放数据，因为输入进程需要计算进程释放缓冲区is。

对于计算进程：如果没有输入进程释放缓冲区ps，计算进程不能多次连续进入缓冲区取走数据。


###### 利用信号量实现前趋关系
通过共享一个公用信号量S，并赋予初值为0，实现进程之间的前驱关系
如：将signal(S)操作放在进程S1前面，weight(S)放在进程S2后面，就可以实现S1àS2的前趋关系

练习！？

##### 管程机制
管程：进程同步的管理工具

- **硬件资源和软件资源**均可用数据结构（少量的信息、可表示对资源执行的操作）抽象地描述其资源特性
- 利用**共享数据结构**抽象地表示系统中的共享资源，并对其数据结构实时的特点操作定义为一组过程（进行PV操作的函数）
- 进程对共享资源的申请、释放和其他操作都需要通过这组过程，间接对共享数据结构实现操作
- 对于并发进程，可以根据资源的情况接受或阻塞，确保每次仅有一个进程进入管程，执行过程、使用共享资源，达到对共享资源所有访问的统一管理，实现进程互斥

（？？不太理解 得看视频

#### 5 经典进程的同步问题⭐
##### 生产者-消费者问题
假设缓冲池中有*n个缓冲区*，每个缓冲区存放一个消息；可利用*互斥信号量mutex*使诸进程对缓冲池实现互斥访问；利用empty和full计数信号量分别表示空缓冲及满缓冲的数量。又假定这些生产者和消费者互相等效，只要缓冲池未满，生产者可将消息送入缓冲池；只要缓冲池未空，消费者可从缓冲池取走一个消息。

互斥信号量：
	mutex：防止多个进程同时进入临界区
同步信号量：
	empty和full：保证事件发生的顺序
	缓冲区满时，Producer停止运行
	缓冲区空时，Consumer停止运行
概念差别——互斥与同步（并发的两个要素）
	互斥：保护临界区，防止多个进程同时进入
	同步：保证进程运行的顺序合理（满了不能再放，空了不能再取）

```
mutex, full, empty: semaphore
mutex :=1; full :=0; empty :=n;

//生产者
whiel(true){
	P(empty);
	P(mutex);
	Buffer(in)=nextp;
	in :=(in+1) mod n;
	V(mutex);
	V(full);
}

//消费者
while(true){
	P(full);
	P(mutex);
	netxc=buffer(out);
	out :=(out+1) mod n;
	V(mutex);
	V(empty);
}
```

##### 哲学家进餐问题
有五个哲学家共用一张圆桌，分别坐在周围的五张椅子上，在圆桌上有五个碗和五支筷子，他们的生活方式是交替地进行思考和进餐。平时，一个哲学家进行思考，饥饿时便试图取用其左右最靠近他的筷子，只有在他拿到两只筷子时才能进餐。进餐毕，放下筷子继续思考。




##### 读者和写者问题
进阶生产者消费者问题

读者：访问互斥？是不是第一个/最后一个？
写者：能不能写

练习：

博物馆1
信号量：总量，门口是否有人
*不理解 搞不懂 什么意思啊 zc zc 6666 我是🤡*

博物馆2


#### 6 进程通信
##### 进程通信的类型
1. 共享存储器系统
	基于共享数据结构的通信方式
	基于共享存储区的通信方式
2. 管道通信系统
	利用一个缓冲传输介质连接两个相互通信的进程
3. 客户机-服务器系统
4. 消息传递系统
	直接通信方式
	间接通信方式

##### 消息传递通信的实现方式
1. 直接消息传递系统
	直接通信原语：
	1. 对称寻址方式
	2. 非对称寻址方式
	消息格式
	进程的同步方式
	通信链路
2. 间接消息传递系统：信箱通信



#### 7 线程的基本概念
##### 线程的引入
引入进程是为了解决什么问题？
解决单处理机环境下的程序并发执行问题
	进程是一个可拥有资源的独立单位
	进程是一个可独立调度和分派的基本单位

###### 线程的基本概念
线程是进程的一部分，描述指令流执行状态，它是进程中==指令执行的最小单元，是CPU调度的基本单位==

###### 线程的优点
一个进程中可以同时存在多个线程
各个线程间可以并发执行
各个线程之间可以共享地址空间和文件等资源

###### 线程的缺点
一个线程崩溃，会导致所属进程的所有其他线程崩溃

###### 进程的两个基本属性
资源的拥有者：进程还是资源的拥有者
CPU调度单位：线程继承了这个属性

###### 线程与进程的比较
- 调度的基本单位：线程作为调度和分派的基本单位
- 并发性：引入线程的OS并发度更高
- 拥有资源：线程本身不拥有系统资源，仅有一点必不可少的资源
- 独立性：线程之间独立性低，共享进程的内存地址空间和资源
- 系统开销：线程的开销低
- 支持多处理机系统：线程更适合多处理机

###### 线程和进程的关系
一个线程只能属于一个进程，而一个进程可以有多个线程，至少有一个线程。
资源分配给进程，同一进程的所有线程**共享**该进程的所有资源。
处理机分给线程，即真正在处理机上运行的是线程。
线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。线程是指进程内的一个执行单元，也是进程内的可调度实体

###### 线程和进程的区别
调度：线程作为调度和分配的基本单位，==进程作为拥有资源的基本单位==
并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行
拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源
系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销

###### 线程的三个运行状态
执行状态
就绪状态
阻塞状态

###### 线程控制块TCB
线程标识符、一组寄存器、线程运行状态、优先级、线程专有存储区、信号屏蔽、堆栈指针

###### 多线程OS中的进程属性
进程是一个可拥有资源的基本单位
多个进程可并发执行
进程已不是可执行的实体

#### 8 线程的实现
##### 线程的实现
###### 用户级线程ULT
在用户空间建立线程库：提供一组管理线程的过程
运行时系统：完成线程的管理工作(操作、线程表)
内核管理的还是进程：内核不知道线程的存在
线程切换不需要内核态特权
例子：UNIX

优点
•线程切换不需转换到内核空间，节省了模式切换的开销
•调度算法是应用程序特定的
•用户级线程可运行在任何操作系统上（只要实现了线程库）

缺点
•内核只将处理器分配给进程，同一进程中的两个线程不能同时运行在两个处理器上
•大多数系统调用是阻塞的，因此，由于内核阻塞进程，故进程中的所有线程也被阻塞

###### 内核支持线程KST
内核管理所有线程管理，并向应用程序提供API
内核维护进程和线程的上下文
线程的切换需要内核支持
以线程为基础进行调度
例子：Windows

优点
•在多处理器系统中，内核能够同时调度同一进程中的多个线程并行执行
•如果进程中一个线程被阻塞，并不会同时阻塞同一进程中的其他线程
•具有很小的数据结构和堆栈，线程的切换比较快
•内核本身也可以采用多线程技术，提高执行速度和效率

缺点
模式切换开销较大

###### 组合方式
线程创建在用户空间完成
进程调度等在核心态完成
例子：Solaris

组合方式——三种模型
- 一对一：为每一个用户线程都设置一个内核控制线程与之连接，当一个线程阻塞时，允许调度另一个线程运行。并行能力较强，但开销较大，因此需要限制整个系统的线程数（Windows 2000/NT等）
- 多对一：将多个用户线程映射到一个内核控制线程，为了管理方便，这些用户线程一般属于一个进程，运行在该进程的用户空间，对这些线程的调度和管理也是在该进程的用户空间中完成。线程管理的开销小效率高，但当一个线程在访问内核时发生阻塞，整个进程都会被阻塞；在多处理机系统中，一个进程的多个线程无法实现并行。
- 多对多：结合上述两种模型的优点，将多个用户线程映射到多个内核控制线程，内核控制线程的数目可以根据应用进程和系统的不同而变化，可以比用户线程少，也可以与之相同。














